/*
*	Expression represents specific structure to generate.
*	Provides context for tokens.
*/
function Expression(){
	return this._constructor.apply(this, arguments)
}

Expression.defaults = {
	context: null, //data context to look up data and functions in. Like gates to the outer world
	maxMultiplier: 99, //max possible multiplier generated by * and +
}

extend(Expression.prototype, {
	_constructor: function(str, options){
		this.tokens = [];//dict of tokens
		this.groups = [];//ordered groups to get access by reference, as usually in regexps
		this.options = extend({}, Expression.defaults, options);

		//Handle real RegExps passed
		if (str instanceof RegExp) str = str.source;

		//Escape all potentially nested token pointers
		var str = this.escape(str);

		//Analyze branches
		this.tokens.length = 1; //reserve place for root
		str = this.flatten(str);

		//Sort out groups		
		this.groupRefRE = new RegExp("(?:[^\\\\]|^)(" + groupRefBrackets[0] + "([0-9]*)" + groupRefBrackets[1] + ")")		
		this.orderGroups(str);

		this.tokens[0] = new GroupToken(str, 1, this);

		return this;
	},

	/*
		Return string with nested groups removed, replaced with group references.
	*/
	groupRE:  /(\((?:\?\:)?[^\(\)]*\))(\?|\*|\+|\{[0-9, ]*\}|)/,
	flatten: function(str){		
		//#ifdef DEV
		var debug = false
		//#endif

		//build tree from innermost branches
		var groupMatch;
		var c = 0; //prevent infinite cycle

		//build innermost branches
		while((group = str.match(this.groupRE)) !== null  && c < 9){
			//#if DEV
			debug && console.group("group:", "'" + group[1] + "'", "'" + group[2] + "'")
			//#endif

			var token = new GroupToken(group[1], group[2], this);
			str = str.replace(group[0], groupRefBrackets[0] + token.idx + groupRefBrackets[1]);

			//#if DEV
			debug && console.groupEnd();
			//#endif
			c++
		}

		return str;
	},

	/*
	*	Calc groups sequence
	*/
	orderGroups: function(str){
		var matchGroupRef, c = 0;
		this.groups.length = 1; //start with 1;
		while ((matchGroupRef = str.match(this.groupRefRE)) !== null && c < this.tokens.length){
			if (this.tokens[~~matchGroupRef[2]].groupType === "(") this.groups.push(this.tokens[~~matchGroupRef[2]]);
			str = str.replace(matchGroupRef[1], this.tokens[~~matchGroupRef[2]].toString(true))
			c++;
		}
	},


	/*
		Cleans string from occasinal token pointers
	*/
	escape: function(str){
		str = str.replace(groupRefBracketRE[0], "\\" + groupRefBrackets[0]);
		str = str.replace(groupRefBracketRE[1], "\\" + groupRefBrackets[1]);
		return str
	},

	/*
	* Vice-versa action: convert `\%` to `%`
	*/
	unescape: function(str){
		str = str.replace(escapedGroupRefBracketRE[0], groupRefBrackets[0]);
		str = str.replace(escapedGroupRefBracketRE[1], groupRefBrackets[1]);
		return str;
	},


	/*
		Gets generated instance based on this expression
	*/
	populate: function(){
		return this.unescape(this.tokens[0].populate());
	},

	/*
		Returns rendered string, representing initial expression string, optimized if it is possible
	*/
	toString: function(){
		return this.tokens[0].toString()
	},

	toJSON: function(){
		return this.tokens[0].toJSON()
	}

})