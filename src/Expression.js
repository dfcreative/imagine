/*
*	Expression represents specific structure to generate.
*	Provides context for tokens.
*/
function Expression(){
	return this._constructor.apply(this, arguments)
}

Expression.defaults = {
	context: null, //data context to look up data and functions in. Like gates to the outer world
	maxMultiplier: 99, //max possible multiplier generated by * and +
}

extend(Expression.prototype, {
	_constructor: function(str, options){
		this.tokens = [];//dict of tokens
		this.groups = [];//ordered groups to get access by reference, as usually in regexps

		this.options = extend({}, Expression.defaults, options);

		//Handle real RegExps passed
		if (str instanceof RegExp) str = str.source;

		//Escape all potentially nested token pointers
		var str = this.escape(str);

		//Analyze branches
		this.tokens.length = 1; //reserve place for root
		str = this.flatten(str);

		//Sort out groups		
		this.orderGroups(str);

		this.tokens[0] = new GroupToken(str, 1, this);

		return this;
	},

	/*
	*	Return string with nested groups removed, replaced with group references.
	*	Start with replacing innermost tokens with references, like {{ a }} → <1>, (b) → <2>
	*/
	groupRE:  /(\((?:\?\:)?[^\(\)]*\))(\?|\*|\+|\{[0-9, ]*\}|)/,
	//dataRE:  /(\{\{[^](?!)*\}\})(\?|\*|\+|\{[0-9, ]*\}|)/, //TODO: ?impossible to catch nested double-jsons
	reversiveDataRE:  /(\?|\*|\+|\}[0-9, ]*\{|)(\}\}(?:[^](?!\{\{))*[^]\{\{)/,
	flatten: function(str){		
		//#ifdef DEV
		var debug = true
		//#endif

		var match;
		var c = 0, limit = 999 //prevent infinite cycle

		//At first, flatten data tokens
		//It is imposible to make two front braces by JSON, but it is possible to do back-braces
		//That may confuse parsing and it is impossible to catch them. 
		//The trick is to inverse the string, catch data-tokens and reverse it back.		
		//{{ int(int(3)) }}{1, 2}{{ none({a: { b: 234 }}) }}
		//}} )}} 432 :b { :a {(enon {{}2 ,1{}} ))3(tni(tni {{
		str = reverse(str);
		while((match = str.match(this.reversiveDataRE)) !== null && c < limit){
			//#if DEV
			debug && console.group("data:", "'" + reverse(match[2]) + "'", "'" + reverse(match[1]) + "'")
			//#endif				

			var token = new DataToken(reverse(match[2]), reverse(match[1]), this);
			str = str.replace(match[0], refBrackets[1] + token.idx + refBrackets[0]);

			//#if DEV
			debug && console.groupEnd();
			//#endif
		}
		str = reverse(str);

		//Then flatten groups
		c = 0;
		while( (match = str.match(this.groupRE)) !== null  && c < limit){
			//#if DEV
			debug && console.group("group:", "'" + match[1] + "'", "'" + match[2] + "'")
			//#endif				

			var token = new GroupToken(match[1], match[2], this);
			str = str.replace(match[0], refBrackets[0] + token.idx + refBrackets[1]);

			//#if DEV
			debug && console.groupEnd();
			//#endif
			c++;
		}

		return str;
	},

	/*
	*	Calc groups sequence
	*/
	groupRefRE: new RegExp("(?:[^\\\\]|^)(" + refBrackets[0] + "([0-9]*)" + refBrackets[1] + ")"),
	orderGroups: function(str){
		var matchGroupRef, c = 0;
		this.groups.length = 1; //start with 1;
		while ((matchGroupRef = str.match(this.groupRefRE)) !== null && c < this.tokens.length){
			var token = this.tokens[~~matchGroupRef[2]];
			if (token instanceof GroupToken && token.groupType === "(") this.groups.push(token);
			str = str.replace(matchGroupRef[1], token.toString(true))
			c++;
		}
	},


	/*
		Cleans string from occasinal token pointers
	*/
	escape: function(str){
		str = str.replace(refBracketsRE[0], "\\" + refBrackets[0]);
		str = str.replace(refBracketsRE[1], "\\" + refBrackets[1]);
		return str
	},

	/*
	* Vice-versa action: convert `\%` to `%`
	*/
	unescape: function(str){
		str = str.replace(escapedRefBracketsRE[0], refBrackets[0]);
		str = str.replace(escapedRefBracketsRE[1], refBrackets[1]);
		return str;
	},


	/*
		Gets generated instance based on this expression
	*/
	populate: function(){
		return this.unescape(this.tokens[0].populate());
	},

	/*
		Returns rendered string, representing initial expression string, optimized if it is possible
	*/
	toString: function(){
		return this.tokens[0].toString()
	},

	toJSON: function(){
		return this.tokens[0].toJSON()
	}

})