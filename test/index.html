<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Tests</title>
	<link rel="stylesheet" href="qunit.css">
</head>
<body>
	<div id="qunit"></div>
	<div id="qunit-fixture"></div>
	
	<script src="../src/util.js"></script>
	<script src="../src/Expression.js"></script>
	<script src="../src/Token.js"></script>
	<script src="../src/GroupToken.js"></script>
	<script src="../src/GroupRefToken.js"></script>
	<script src="../src/StringToken.js"></script>
	<script src="../src/DataToken.js"></script>
	<script src="../src/AnyToken.js"></script>
	<script src="../src/DataDescriptor.js"></script>
	<script src="../src/Improvise.js"></script>

	<script src="../data/Internet.js"></script>

	<script src="qunit.js"></script>

	<script type="text/javascript">
		test("escape, unescape", function(){
			ok(escape("12345*+{}[]", "][") === "12345*+{}\\[\\]", "escape techs");
			ok(escape("\\", "\\") === "\\\\", "escape \\");
			ok(escape("123\\456", "\\") === "123\\\\456", "escape \\ 2");

			ok(unescape("\\", "\\") === "\\", "unescape \\")
			ok(unescape("\\\\", "\\") === "\\", "unescape \\\\")
			ok(unescape("123\\\\456", "\\") === "123\\456", "unescape \\\\")
			ok(unescape("12345\*\+\{\}\[\]", "][*+{}") === "12345*+{}[]", "unescape techs")
		})

		test( "number, float, int, bool", function() {
			var isOk = [false, false, false];
			for (var i = 0; i < 30; i++){
				var c = Math.round(improvise.number(-1.2, 1.2));
				if (c === 1){
					isOk[2] = true;
				}
				if (c === 0){
					isOk[1] = true;
				}
				if (c === -1){
					isOk[0] = true;
				}
			}
			ok( isOk[0] && isOk[1] && isOk[2], "distribution");
			ok(improvise.number(12) <= 12, "maximal int");
			ok (Math.max(improvise.number(12), improvise.number(12), improvise.number(12) ) > 3, "minimal int");
			ok ([0,1,2,3,4].indexOf(improvise.int(4)) >= 0, "int rounding");
			ok ([1,2,3,4].indexOf(improvise.float(4)) < 0, "float not rounding");
			ok ([2,3,4,5].indexOf(improvise.int(2,5)) >= 0, "int range");
			ok (improvise.float(2,4) > 2 && improvise.float(2,4) < 4, "float range");
			ok (improvise.int(-2, -2) === -2, "int exactness");
		});

		test( "any", function(){
			var arr = [1,2,3,4,5];
			isOk = [];
			for (var i = 0; i < 40; i++){
				var c = improvise.any(arr);
				var idx = arr.indexOf(c);
				if (idx >= 0) isOk[idx] = true;
			}
			ok(isOk.length === 5);

			ok(any() === undefined, "empty");

			ok(any(123) === 123, "number passed");

			ok([1,2,3].indexOf(any(1, 2, 3)) >= 0, "sequence of arguments");

			ok(any([]) === undefined, "empty array passed");
		});

		test( "replacements", function(){
			var str = "Nn?-?";
			var replacements = {
				'N': '123456789',
				'n': '0123456789',
				'?': 'abcdefghijklmnopqrstuvwxyz'
			};
			var res = improvise.replacements(str, replacements);
			ok (replacements['N'].indexOf(res[0]) >= 0 &&
				replacements['n'].indexOf(res[1]) >= 0 &&
				replacements['?'].indexOf(res[2]) >= 0 &&
				res[3] === "-" &&
				replacements['?'].indexOf(res[4]) >= 0, "Replacements")
		});

		test( "sanitize", function(){
			var testHTML = "<html>start\n<script>123<\/script\><object\/\>\nend<\/html\>";
			ok ( improvise.sanitize(testHTML) == "<html>start\n\nend</html>" );
		});

		test("expression parsing", function(){

			ok(improvise.expression("(a)3") === 'a3', "Group escaping: number after group")
			ok(improvise.expression('%5%(%6%a%7%)%8%') === '%5%%6%a%7%%8%', "Group escaping: extra percents")
			ok(improvise.expression('%5(a)') === "%5a", "Group escaping: odd percents number")

			//<5>(<6>a<7>)<8>
			var initialStr = [
					I.refBrackets[0], 5,
					I.refBrackets[1], '(',
					I.refBrackets[0], 6,
					I.refBrackets[1], 'a',
					I.refBrackets[0], 7,
					I.refBrackets[1], ')',
					I.refBrackets[0], 8,
					I.refBrackets[1]
				].join('')
			var resultingStr = initialStr.replace(/[\(\)]/g, '');

			ok(improvise.expression(initialStr) === resultingStr, "GroupRef escaping: " + initialStr + " populate→ " + resultingStr)
			ok(new Expression(initialStr).toString() === initialStr, "GroupRef escaping: " + initialStr + " toString→ " + new Expression(initialStr).toString())

			ok(new Expression('a(b)c').toString() === "a(b)c", "One symbol parsing: " + "a(b)c →" + new Expression('a(b)c').toString())
		})

		test("expression correctness", function(){
			var str = "ab{0,2}c(?:de?f|(hj{1}k|lm[nN]?({{ o }})?{3,}pq|rst?))?uv|[x]{0,2}(y){{z}}\\2{,1}\\1(abc\\td%4ef\\*\\x123)+z?"
			var expr = new Expression(str);

			ok (expr.toString().indexOf("") < 0, "Bad symbols handling")

			ok (expr.toString() == "ab{0, 2}c(?:de?f|(hjk|lm[nN]?({{ o }})?{3,}pq|rst?))?uv|[x]{0, 2}(y){{ z }}\\2?\\1(abc\\td%4ef\\*x123)+z?", "Proper toString: " + expr.toString())

		})

		test("expression trivial populate", function(){
			var str = "(?:(greg).(semenov)|\\2.\\1)@(gmail|yahoo).com"
			var expr = new Expression(str);

			var result = expr.populate();

			ok (["greg.semenov@gmail.com","semenov.greg@gmail.com","semenov.greg@yahoo.com","greg.semenov@yahoo.com"].indexOf(result) >= 0, "Populate simple email failed")
		})


		test("handle real regexps", function(){
			ok (expression(/abc/) === "abc")
		});

		test("forward and backward expressions compatibility", function(){
			//TODO: test matching of result by the same regex as expression is
			var regex = new RegExp("a[bc](def)g");
			var result = expression(regex);
			var match = result.match(regex);

			ok(match[1] === "def", "Simple groups matching test")
		});


		test("expression AnyToken", function(){
			var testStr = "[ab0-9cde-gа-г]";
			ok("ab0123456789cdefgабвг".indexOf(expression(testStr)) >= 0)

			testStr = "[-]"
			ok(expression(testStr) === "-")

			testStr = "[a-]"
			ok("a-".indexOf(expression(testStr)) >= 0)

			testStr = "[-u]"
			ok("u-".indexOf(expression(testStr)) >= 0)

			testStr = "[---]"
			ok(expression(testStr) === "-")

			testStr = "[a-c-f]"
			ok("abc-f".indexOf(expression(testStr)) >= 0)
		})


		test("expression DataToken", function(){
			ok(expression("{{ int(0) }}") == 0, "Trivial int(0) check")
			ok(expression("{{ none({a: { b: 234 }}) }}") === null, "Correctness of nested JSON like {a: {b: }}")
			ok(expression("{{ none('}}}}{{{{', '{{{{}}}}', {a:{}}) }}") === null, "Correction of nested vicissitudes")


			ok(expression("{{ 'abc' }}") === 'abc', "Primitives: strings")
			ok(expression("{{ 123.456 }}") === 123.456, "Primitives: numbers")
			ok(expression("{{ 2 + 2 }}") === 4, "Primitives: operations")
			ok(expression("{{ function(){} }}") === 4, "Primitives: operations")
		});


		test("mimic json generator repeat & index", function(){
			console.log(populate({ name: '{{ firstName }}' }))

			//repeating & index tests
			deepEqual(populate(["{{ repeat(3) }}", '{{ index(12) }}']), [12,13,14])

			deepEqual(populate(['{{ index(22) }}']), [22])

			equal(populate('{{ index(23) }}'), 23)

			equal(populate('{{ repeat(3) }}'), undefined)

			deepEqual(populate(['{{ repeat(3) }}']), [,,])

			deepEqual(populate([{id: '{{ index(32) }}', r: '{{ repeat(3) }}'}]), {id: 32, r: undefined})

			deepEqual(populate(['{{ repeat(7) }}', '{{ index(1) }}', '{{ index(2) }}', '{{ index }}']), [1,2,2, 3,3,4, 5,4,6, 7])
		});

		test("mimic json generator properties", function(){
		});


		test("populate data descriptors", function(){
			//console.log(populate({ name: Person.name }))
			//ok(populate({ name: Person.name }), {})
			//console.log(expression(Internet.email))
		})

		test("data-providers", function(){
			//console.log(expression(Internet.email))
		})


		test("data descriptors recognition", function(){
		})

	</script>
</body>
</html>